1.在xml中引入配置trancationManager这个类的bean.
2.在需要的类或者方法上,使用transcational注解即可.

  原理也就是使用代理,会经过一个transacrionIntercapter的拦截器,对执行方法进行拦截,执行方法,根据方法执行结果判断是否进行回滚.
  注意:在一个没有加transaction注解的方法中调用有transaction注解的非法是不会产生事务的,因为这时候调用的方法的直接对象,并不是代理对象(有一个ifelse的判断语句).
          而在直接调用有transaction注解的方法,会调用代理对象,开启事务.
     
          当一个类加了transcation注解后,注入spring容器的就是对应的代理对象.方法是会进行判断是否需要拦截(自己猜测).

二.事务传播行为.(使用Propagation指定)
    requare:支持当前事务，假设当前没有事务。就新建一个事务
    requare_New:新建事务，假设当前存在事务。把当前事务挂起
    suppout:支持当前事务，假设当前没有事务，就以非事务方式运行
    not_support:以非事务方式运行操作。假设当前存在事务，就把当前事务挂起
    mandatory:强制的.支持当前事务，假设当前没有事务，就抛出异常
    never:以非事务方式运行，假设当前存在事务，则抛出异常
    nested:嵌套事务,如果当前已经存在一个事务,那么该方法将会在嵌套事务中运行,嵌套的事务可以独立于当前的事务进行回滚或提交.
               如果当前事务不存在,那么于requare的行为一样.

   为什么要有传播行为?
      methodA事务方法调用methodB事务方法时，methodB是继续在调用者methodA的事务中运行呢，还是为自己开启一个新事务运行，这就是由methodB的事务传播行为决定的。
    

