一.概念.
  Redis是一个开源的,可修改源代码的,基于进制队(相当于map)的存储服务器.
一.Redis初识:
   1.速度快.(每秒有几万的QPS,读写)
     原因:
         a.存储在内存里面,不落地.
         b.用C语言编写,代码只有5万行,优秀的代码.
         c.用单线程,因为存储在内存里,不会有多线程的切换,共享等浪费资源.
   2.持久化(重启数据不会丢失)
     a.存储在内存中关机数据就会丢失,那么Redis会异步存储到本地磁盘.异步,不影响redis正常操作.
     b.两种持久化机制
       RDB:一个快照保存,会fonk一个进程,遍历hashtable,用copy on right的方式,把整个db都dump下来,保存到磁盘里. 
       AOF:会把写的指令持续的写到一个AOF文件当中,相当于mysql事物中的日志文件一样.(只记录写的操作),粒度小
       区别:RDB只有收到操作save或其他命令时,才会触发存储操作.
            而AOF会持续不断的写入到日志文件中.
   3.多种数据结构
     主要五种:
            字符串,哈希,链表,集合,有序集合.
   4.支持多种编程语言
       提供一个简单的DCP协议.其他编程语言接入很简单.
   5.功能丰富.
     a.比如发布订阅,可以实现一个基于消息的功能,像消息队列一样.
     b.强大的脚本.
     c.实现一个简单的事务.
   6.简单易学.
     a.核心代码少.
     b.不依赖其他的第三方库文件.
     c.单线程模型.
   7.主从复制.
       有两种角色,主服务器和从服务器,主服务器的数据会同步到从服务器中
       高可用和分布式的基础.
   8.高可用,分布式.
      高可用:
        如果主节点挂了,会从其他从节点中选出来去代替.基节点数必须是2n+1.
   9.在实际生产环境中,通常会为数据设置标签,标签不一样,代表数据访问频率不一样,所以数据的过期时间不一样,频率越高,过期时间越长.
      还有冷数据,也就是不经常访问的数据,要分散,就是过期时间不要一致,以免在统一时间失效,增加数据库压力,这个时候我们可以设置一定范围内的随机值.

copy on write:
   Java中:为了解决并发场景下读写冲突的场景,提高并发读写的读性能.
   文件系统:为了防止系统突然掉电,保证数据的完整性.
   具体思想:
          如果有多个调用者同时请求相同资源,将会获得相同的指针指向共同的资源,直到某个调用者试图修改资源内容时
   才copy一份专用副本给该调用者a,其他调用仍然访问原有资源,直到调用者a对副本修改完毕后,所有调用者获取的指针全部指向修改好的副本.
 
  问题: 
      为什么要copy副本?这样做有什么好处?
  如果不copy副本,那么就只能在原有容器中做修改,此时势必对容器加锁,而这个锁就会阻塞读操作,影响读性能,但是copy副本则不会,只需要对整个写操作加锁,读操作是不需要加锁的.因为读操作所读的容器永远不会发生修改.	

  所以copy on write会保证数据的最终一致性,并不保证实时一致性.
          
   

    